# 设计模式

概念：设计模式是前辈们对代码开发经验的总结，是解决决定问题的一系列套路，它不是语法规定，而是一种用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。

23种设计模式，GOF设计模式，应用于面向对象的。

基本要素：

- 模式名称：
- 问题：
- 解决方案：
- 效果（优缺点）：

所有的模式可以分成三类：

- 创建型模式（5种）：单例模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式、
- 结构型模式（七种）：适配器模式、桥接模式、代理模式、装饰品模式、组合模式、外观模式、享元模式
- 行为型模式（十一种）：策率模式、模板方法设计模式、迭代器模式、命令模式、观察者模式、责任链设计模式、解释器模式、中介者模式、访问者模式、状态模式、备忘录模式。



面向对象的七大原则：

- 开闭原则：对扩展开放，对修改关闭
- 里氏替换原则：就是说 你编写一个类继承某一个类的时候，尽可能保证不去修改父类的代码，而是扩展自己的方法。
- 依赖倒置原则：要面向接口编程，不要面向实际编程。
- 单一职责原则：控制类的粒度大小，将对象解耦，提高其内聚性      就是一个方法尽可能处理好一件事情
- 接口隔离原则：要为各个类建立他们需要的专用接口。
- 迪米特原则：只与你直接的朋友通信，而避免和陌生人通信
- 合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现



## 单例模式

定义：单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例

特点：

- 单例类只能有一个实例
- 单例类必须自己创建自己的唯一实例
- 单例类必须给所有其他对象提供这一实例

线程安全问题：

- 首先，在获取单例的时候，要保证不能产生多个实例对象
- 在使用单例对象的时候，要注意单例对象内的实例变量会被多线程共享的。



饿汉式、懒汉式、DCL懒汉式、内部类方式、枚举类型



应用场景：

在Servlet编程中，每一个Servlet都是单例的

在Spring种，每一个Bean默认都是单例的

数据库连接池的设计一般也是单例模式



## 工厂模式

作用：创建者和调用者分离

详细分类：

- 简单工厂模式（在增加新的产品的时候，需要改变原来的代码）

  - 一个车辆工厂的例子

    - 首先新建一个car接口，所有的车都需要实现这个接口，这个接口提供一个方法name

    - ~~~java
      public interface Car {
          void name();
      }
      ~~~

    - 创建一个simple方法，这个方法对外提供给消费者使用

    - ~~~java
      public class Simple {
          // 方式一
          public static Car getCar(String str){
              if(str.equals("WuLing")){
                  return  new WuLi();
              }else if(str.equals("Tesla")){
                  return new Tesla();
              }else{
                  return null;
              }
          }
          // 方式二
          public static Car getWuLing(){
              return new WuLi();
          }
      
          public static Car getTesla(){
              return new Tesla();
          }
      }
      ~~~

    - 两种方式对消费者提供获取车辆的方法，可以通过创建simple对象的时候传递字符串参数，才达到获取指定车辆的目的，也可以通过get某一品牌车直接获取到车辆

    - ~~~java
      public class Consumer {
          public static void main(String[] args) {
              Car car1 = Simple.getCar("WuLing");
              Car car2 = Simple.getCar("Tesla");
              car1.name();
              car2.name();
          }
      }
      ~~~

      这种方法我们发现在横向扩展上不是那么的合适 ，每次增加新的车辆，对源代码我们都需要进行更改

- 工厂方法模式（支持新增产品，不需要改动原来代码，带式会增加很多类）

  - 去掉simple类，增加一个CarFactory接口类，所有的车辆都对应着相对的工厂，这些工厂都需要实现CarFactory这个接口

  - ~~~java
    public interface CarFactory {
        Car getCar();
    }
    ~~~

  - ```java
    public class WuLingFactory implements CarFactory {
        @Override
        public Car getCar() {
            return new WuLing();
        }
    }
    ```

  - ```java
    public class Consumer {
        public static void main(String[] args) {
            Car car = new WuLingFactory().getCar();
            car.name();
        }
    }
    ```

  - 这样扩展新车的时候，需要创建一个新的车类，创建一个对应的车的工厂，然后我们拿车，这样就实现代码的横向扩展，我们不需要改动原来的代码。

- 上边总结，根据设计原则：使用工厂方法

- 但是根据实际业务：是使用简单工厂的

- 抽象工厂模式
  - 生产工厂的工厂，超级工厂，负责创建其他工厂的
  - 三个东西，产品、（抽象的可以生产各种产品）产品厂、具体的产品厂
  - 凡是实现产品厂的，那就得实现里边的产品  ，就是创造了工厂

核心本质

- 实例化对象的时候，不使用new关键字，使用工厂方法替代
- 将选择实现类，创建对象统一管理和控制，从而将调用者跟实现类解耦合



## 建造者模式

创造性模式，提供了一种创建对象的最佳方式

定义：将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示（建房的例子，相同的步骤可以完成不同的房子的设计）

主要作用：在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象

工厂模式去生产零件，建造者模式去生产复杂的对象   混合使用设计模式

Director  指挥  Builder(抽象的)      具体的Builder     生产   最终的产品



优点：产品的建造和表示分离，实现了解耦，这个模式可以使客户端不必知道产品内部组成的细节

- 创建步骤分解到不同的方法址中，使疮见过程更加清晰
- 因为创建的东西都不相同，所以符合开闭原则



对于具有相似过程的比较适合建造者模式，不一样的不适合  比方说盖房 大体上是一样的

相同的创建过程，可以创建出来不一样的东西  产品     只会不同的工人，产生不同的产品



## 原型模式（prototype）

以某个对象为原型，复制克隆出来一个新的对象，方便与在创建一个复杂对象的时候提高效率

创建的对象较为复杂的时候，可以利用原型模式简化对象的创建过程，提高效率





浅克隆：原型类实现Cloneable接口，重写Object类的clone方法，浅克隆不会克隆对象的属性，只会指向同一片内存空间，当属性内容改变之后，都会发生改变

深克隆：对对象的属性进行克隆，该谁的谁的熟悉哪个就发生对应的改变，在实现深拷贝的时候可能需要比较复杂的代码









